""" 
BD_update_PBI

Módulo que acessa as funcionalidades do sistema FLUID e permite manipulação de arquivos .xls
para a atualização de relatórios do PowerBI.

Author: Juliano Kosloski - Automation Developer
Created: 30/09/2022 by Juliano Kosloski
"""

import dotenv
import os
import re
import time
import datetime
import openpyxl
import pyautogui
from selenium import webdriver
# from selenium.webdriver.chrome.service import Service
from selenium.webdriver.edge.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import NoSuchElementException
from selenium.common.exceptions import ElementNotInteractableException

class BD_update_PBI: 
    
    def startDriver():
        """
        Starts up the Chrome/Edge WebDriver config and returns a readied driver instance
        """

        # option = webdriver.ChromeOptions() 
        # option.binary_location = "C:/PATH//chrome.exe"  #dev
        # option.binary_location = "C:/PATH//chrome.exe"  #robot machine
        # driverService = Service('C:/PATH//chromedriver.exe') #sets up a driver service 
        # driver = webdriver.Chrome(service=driverService, options=option) #starts the driver
        
        option = webdriver.EdgeOptions() 
        # option.binary_location = "C:/PATH/\msedge.exe"  #dev
        option.binary_location = "C:/PATH/\msedge.exe"  #robot machine
        driverService = Service('C:/PATH//msedgedriver.exe') #sets up a driver service 
        driver = webdriver.Edge(service=driverService, options=option) #starts the driver

        return driver
    
    def __getCred__(sic_system : str) -> tuple: 
        """
        Gets appropriate credentials and returns them for in-class use
        """
        
        if sic_system == "Fluid":

            dotenv.load_dotenv(dotenv.find_dotenv())
            sysLogin = os.environ.get("USER_FLUID")
            sysPassword = os.environ.get("PASS_FLUID")
                    
            return sysLogin, sysPassword
        
        elif sic_system == "AdmCanais":
            
            dotenv.load_dotenv(dotenv.find_dotenv())
            sysLogin = os.environ.get("USER_ADM_CANAIS")
            sysPassword = os.environ.get("PASS_ADM_CANAIS")
                    
            return sysLogin, sysPassword
    
    def getLogin(driver, sic_system : str) -> None:
        """
        Takes a new driver instance and logs into a specific website

        params:
        driver: a WebDriver instance generated by other function
        sic_system: system to get credentials
        """

        sysLogin, sysPassword = BD_update_PBI.__getCred__(sic_system) 

        if sic_system == "Fluid":
            
            driver.get("https://ewqewqew/rio")
            time.sleep(5)
            #finds user field
            element = driver.find_element(By.XPATH,"/html/body/div/div[1]/section/div[1]/div/form/div[1]/div/input" )
            element.clear()
            element.click()
            element.send_keys(sysLogin)
            #finds password field
            element = driver.find_element(By.XPATH, "/html/body/div/div[1]/section/div[1]/div/form/div[2]/div/input")
            element.clear()
            element.click()
            element.send_keys(sysPassword)
            #finds login buttom
            element = driver.find_element(By.XPATH, "/html/body/div/div[1]/section/div[1]/div/form/div[3]/div/button")
            element.click()
            
        elif sic_system == "AdmCanais":
            
            driver.get("https://asdasdasdadsad.com")
            time.sleep(5)
            #finds user field
            element = driver.find_element(By.ID, "fieldUser")
            element.clear()
            element.click()
            element.send_keys(sysLogin)
            #finds password field
            element = driver.find_element(By.ID, "fieldPassword")
            element.clear()
            element.click()
            element.send_keys(sysPassword)
            #finds login buttom
            element = driver.find_element(By.ID, "btnSubmit")
            element.click()
        
        time.sleep(5)

    def getLink(driver, url :str = "", attempts = 1) -> None:
        """
        Navigates to a link on the web

        params:
        driver: a WebDriver instance generated by other function
        url: a string link to a webpage
        attempts: int of how many access tries
        """

        tries = 0  
        while tries < attempts: #try to access the website x times
            driver.get(url)
            tries += 1
    
    def startEndPreviousMonth():
        """
        Returns two dates: the first and the last day of the previous month
        """
        
        today = datetime.date.today()
        first = today.replace(day=1)
        lastDay = first - datetime.timedelta(days=1) #goes back one day
        firstDay = lastDay.replace(day=1)
        
        #formatting
        lastDay = lastDay.strftime("%d%m%Y")
        firstDay = firstDay.strftime("%d%m%Y")
        
        return firstDay, lastDay
            
    def _beforeDate(daysBefore:int) -> str:
        """
        Returns a date before the current date (given the parameter)
        
        params:
        daysBefore: how many days before current date
        """
        
        today = datetime.datetime.now()
        d = datetime.timedelta(days = daysBefore)
        beforeDate = today - d
        beforeDate = beforeDate.strftime("%d%m%Y")
        
        return beforeDate
            
    def inputDates(driver, initDay, endDay, alt:bool = False) -> None:
        """
        Inputs dates on the form fields

        params:
        driver: a WebDriver instance generated by other function
        """
        
        date_ini = initDay;
        date_fim = endDay;
        
        if alt == False:
            time.sleep(5)
            # pyautogui.press("tab", presses = 6)
            #finds beginning date
            element = driver.find_element(By.ID,"dt_ini" )
            element.click()
            element.send_keys(date_ini)
            
            time.sleep(5)
            #finds end date
            element = driver.find_element(By.ID,"dt_fim" )
            element.click()
            element.send_keys(date_fim)
        else:
            time.sleep(5)
            # pyautogui.press("tab", presses = 6)
            #finds beginning date
            element = driver.find_element(By.ID,"dt_ini" )
            element.click()
            element.send_keys(Keys.CONTROL, "a") #had to add this step because the website devs chose type=text instead of =date, forcing me to clear the field before typing
            element.send_keys(Keys.BACKSPACE)
            element.send_keys(date_ini)
            
            time.sleep(5)
            #finds end date
            element = driver.find_element(By.ID,"dt_fim" )
            element.click()
            element.send_keys(Keys.CONTROL, "a")
            element.send_keys(Keys.BACKSPACE)
            element.send_keys(date_fim)
        
    def downloadRelFluid(driver, noAdd: bool = False) -> bool: #if there's a problem with Fluid the report might get timed-out
        """
        Interacts with the fields to download a Fluid report

        params:
        driver: a WebDriver instance generated by other function
        """
        
        #finds inspect buttom
        element = driver.find_element(By.XPATH, "//*[@id='form-abertura']/button")
        element.click()
        
        time.sleep(5)
        #finds export buttom

        alert = driver.find_elements(By.XPATH, "/html/body/div[2]/div[1]/div/div[2]/div/div[2]/div/p") #find elements returns an empty list if no element is found
        
        if (alert == []):
            time.sleep(3)
            element = driver.find_element(By.XPATH, "//*[@id='exportModal']/i")
            element.click()
        
            time.sleep(5)
            
            #finds select all buttom
            if (noAdd == False):
                element = driver.find_element(By.XPATH, "//*[@id='rel-export-modal']/div[2]/div/div[3]/a[1]")
                element.click()
            
            time.sleep(2)
            #finds final download buttom
            element = driver.find_element(By.ID, "downloadRel")
            element.click()
            time.sleep(10)
    
            return True
        
        else:
            print("Sem registros para esse periodo!")
            return False
    
    def downloadRelAdmCanais(driver, initDay:int = 7, endDay:int = 1) -> None:

        element = driver.find_element(By.ID, "central")
        element.click()
        element = driver.find_element(By.XPATH,'//*[@id="central"]/option[7]')
        element.click()
        # element.selectByValue("3000")
        time.sleep(3)
        element = driver.find_element(By.ID, "sureg")
        element.click()
        element = driver.find_element(By.XPATH,'//*[@id="sureg"]/option[32]')
        element.click()
        # element.selectByValue("VJ9")
        time.sleep(3)
        element = driver.find_element(By.ID, "cooperativa")
        element.click()
        element = driver.find_element(By.XPATH,'//*[@id="cooperativa"]/option[2]')
        element.click()
        # element.selectByValue("725")
        time.sleep(3)
        
        #input dates
        date_ini = BD_update_PBI._beforeDate(initDay);
        date_fim = BD_update_PBI._beforeDate(endDay);
        
        element = driver.find_element(By.ID,"startDate" )
        element.click()
        element.send_keys(date_ini)
        
        element = driver.find_element(By.ID,"endDate" )
        element.click()
        element.send_keys(date_fim)
    
        element = driver.find_element(By.XPATH, "//*[@id='filtro']/div[3]/div/a")
        element.click()
        time.sleep(40)
        
    def endSession(driver):
        """
        Ends the driver session
        """

        time.sleep(5)
        driver.quit()
    
    def getFilePath(pattern) -> str:
        """
        Search Downloads folder for the updated report and returns its path
        if a match is found
        """
        
        fileMatch = False
        filePath = ""
        #creates a regex pattern to search the dir
        rx = re.compile(pattern)
        
        for file in os.listdir(path = "C:/PATH//Downloads"): # robot machine
        # for file in os.listdir(path = "C:/PATH//Downloads"): #dev
                
            if rx.match(file):
                file_name = file
                fileMatch = True
                print("Um arquivo foi encontrado: " + file_name)
        
        if fileMatch == False:
            pyautogui.alert("Não foi possível encontrar o arquivo nos Downloads! Encerrando programa...")
            raise pyautogui.FailSafeException
        
        # filePath = "C:/PATH//{}".format(file_name)  #----DEV
        filePath = "C:/PATH//Downloads/{}".format(file_name) #ROBOT
        
        return filePath
    
    def saveCorruptedXLSAsXLSX(path:str) -> str:
        """
        Navigates Excel GUI to save a .csv file as .xlsx, returning the new file path 
    
        params:
        path: a string with the file path
        """

        file = os.startfile(path) #opens the file for reading or writing
        time.sleep(15) #wait for the file to load
        
        #this function solves the issue of losing data types when doing direct csv to xlsx conversion
        
        pyautogui.press("left")
        time.sleep(2)
        pyautogui.press("enter")
        time.sleep(5)
        pyautogui.hotkey("alt", "a", interval=2.0) #goes to file options in excel (PT-BR)
        time.sleep(10)
        pyautogui.press("a") #opens save as option
        time.sleep(5)
        pyautogui.hotkey("y", "4") #opens file type selection
        time.sleep(5)
        pyautogui.press("up", presses = 12) #navigates to .xlsx
        pyautogui.press("enter") #confirms the selection
        
        # locPoint = pyautogui.locateCenterOnScreen('smart/assets/test_save.png') #----DEV
        locPoint = pyautogui.locateCenterOnScreen('assets/save.png') # ROBOT finds the save buttom and clicks it
        pyautogui.click(locPoint) 
        
        print("File saved as .xlsx...")
        newPath = path + ".xlsx"
        time.sleep(4)
        
        print("Closing Excel...")
        os.system("TASKKILL /F /IM EXCEL.exe")
        time.sleep(5)
        
        return newPath
    
    def saveXLSAsXLSX(path:str) -> str:
        """
        Navigates Excel GUI to save a .xls file as .xlsx
        """
        
        file = os.startfile(path) #opens the file for reading or writing
        time.sleep(10) #wait for the file to load
        
        pyautogui.hotkey("alt", "a") #goes to file options in excel (PT-BR)
        time.sleep(2)
        pyautogui.press("a") #opens save as option
        time.sleep(2)
        pyautogui.hotkey("y", "4") #opens file type selection
        time.sleep(2)
        pyautogui.press("up", presses = 3) #navigates to .xlsx
        pyautogui.press("enter") #confirms the selection
        
        # locPoint = pyautogui.locateCenterOnScreen('smart/assets/test_save.png') #----Dev
        locPoint = pyautogui.locateCenterOnScreen('assets/save.png') # ROBOT finds the save buttom and clicks it
        pyautogui.click(locPoint) 
        
        print("File saved as .xlsx...")
        newPath = path[:-4] + ".xlsx"
        time.sleep(4)
        
        print("Closing Excel...")
        os.system("TASKKILL /F /IM EXCEL.exe")
        time.sleep(5)
        
        return newPath
            
    def copyFromTo(fromFile:str, toFile:str, toSheet:str, system:str) -> None:
        """
        Copy data from one .xls file to another, ignoring headers
        
        params:
        fromFile: path to the input file
        toFile: path to the output file
        """
        
        if system == "Fluid":
            
            print("Loading worksheets...")
            #load input workbook
            wb_from = openpyxl.load_workbook(fromFile, data_only=True) 
            time.sleep(5)
            ws_from = wb_from.worksheets[0]
            
            #load output workbook
            wb_to = openpyxl.load_workbook(toFile) 
            time.sleep(5)
            ws_to = wb_to[toSheet]
            
            from_maxr = ws_from.max_row
            from_maxc = ws_from.max_column
            
            print("Finding the start row on the destination file...")
            
            c = 1
            i = 1
            while(True):
                check = ws_to.cell(row = i, column = c)
                if check.value == None:
                    to_start_row = i -2   # the subtraction here is to stop the copy from jumping rows in the next loop
                    break
                i += 1
            
            print("Copying data...")
            for i in range (2, from_maxr + 1):
                for j in range (1, from_maxc + 1):
                    # reading cell value from source excel file
                    data = ws_from.cell(row = i, column = j)
            
                    # writing the read value to destination excel file
                    ws_to.cell(row = to_start_row + i, column = j).value = data.value
                
            print("Saving files...")
            time.sleep(5)
            wb_to.save(toFile)  
            time.sleep(5)
            print("Files saved")
        
        if system == "AdmCanais":
            
            print("Loading worksheets...")
            #load input workbook
            wb_from = openpyxl.load_workbook(fromFile, data_only=True) 
            time.sleep(5)
            ws_from = wb_from.worksheets[0]
            
            #load output workbook
            wb_to = openpyxl.load_workbook(toFile) 
            time.sleep(5)
            ws_to = wb_to[toSheet]
            
            from_maxr = ws_from.max_row
            from_maxc = ws_from.max_column
            
            print("Finding the start row on the destination file...")
            
            c = 1
            i = 1
            while(True):
                check = ws_to.cell(row = i, column = c)
                if check.value == None:
                    to_start_row = i -13   # the subtraction here is to stop the copy from jumping rows in the next loop
                    break
                i += 1
            
            print("Copying data...")
            for i in range (13, from_maxr + 1):
                for j in range (1, from_maxc + 1):
                    # reading cell value from source excel file
                    data = ws_from.cell(row = i, column = j)
            
                    # writing the read value to destination excel file
                    ws_to.cell(row = to_start_row + i, column = j).value = data.value
                
            print("Saving files...")
            time.sleep(5)
            wb_to.save(toFile)  
            time.sleep(5)
            print("Files saved")